// Code generated by mockery v2.53.4. DO NOT EDIT.

package repository

import (
	mock "github.com/stretchr/testify/mock"
	repository "github.com/wisaitas/share-pkg/db/repository"
	gorm "gorm.io/gorm"
)

// MockBaseRepository is an autogenerated mock type for the BaseRepository type
type MockBaseRepository[T interface{}] struct {
	mock.Mock
}

type MockBaseRepository_Expecter[T interface{}] struct {
	mock *mock.Mock
}

func (_m *MockBaseRepository[T]) EXPECT() *MockBaseRepository_Expecter[T] {
	return &MockBaseRepository_Expecter[T]{mock: &_m.Mock}
}

// Create provides a mock function with given fields: item
func (_m *MockBaseRepository[T]) Create(item *T) error {
	ret := _m.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*T) error); ok {
		r0 = rf(item)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockBaseRepository_Create_Call[T interface{}] struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - item *T
func (_e *MockBaseRepository_Expecter[T]) Create(item interface{}) *MockBaseRepository_Create_Call[T] {
	return &MockBaseRepository_Create_Call[T]{Call: _e.mock.On("Create", item)}
}

func (_c *MockBaseRepository_Create_Call[T]) Run(run func(item *T)) *MockBaseRepository_Create_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T))
	})
	return _c
}

func (_c *MockBaseRepository_Create_Call[T]) Return(_a0 error) *MockBaseRepository_Create_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_Create_Call[T]) RunAndReturn(run func(*T) error) *MockBaseRepository_Create_Call[T] {
	_c.Call.Return(run)
	return _c
}

// CreateMany provides a mock function with given fields: items
func (_m *MockBaseRepository[T]) CreateMany(items *[]T) error {
	ret := _m.Called(items)

	if len(ret) == 0 {
		panic("no return value specified for CreateMany")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*[]T) error); ok {
		r0 = rf(items)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_CreateMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMany'
type MockBaseRepository_CreateMany_Call[T interface{}] struct {
	*mock.Call
}

// CreateMany is a helper method to define mock.On call
//   - items *[]T
func (_e *MockBaseRepository_Expecter[T]) CreateMany(items interface{}) *MockBaseRepository_CreateMany_Call[T] {
	return &MockBaseRepository_CreateMany_Call[T]{Call: _e.mock.On("CreateMany", items)}
}

func (_c *MockBaseRepository_CreateMany_Call[T]) Run(run func(items *[]T)) *MockBaseRepository_CreateMany_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*[]T))
	})
	return _c
}

func (_c *MockBaseRepository_CreateMany_Call[T]) Return(_a0 error) *MockBaseRepository_CreateMany_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_CreateMany_Call[T]) RunAndReturn(run func(*[]T) error) *MockBaseRepository_CreateMany_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: item
func (_m *MockBaseRepository[T]) Delete(item *T) error {
	ret := _m.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*T) error); ok {
		r0 = rf(item)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockBaseRepository_Delete_Call[T interface{}] struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - item *T
func (_e *MockBaseRepository_Expecter[T]) Delete(item interface{}) *MockBaseRepository_Delete_Call[T] {
	return &MockBaseRepository_Delete_Call[T]{Call: _e.mock.On("Delete", item)}
}

func (_c *MockBaseRepository_Delete_Call[T]) Run(run func(item *T)) *MockBaseRepository_Delete_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T))
	})
	return _c
}

func (_c *MockBaseRepository_Delete_Call[T]) Return(_a0 error) *MockBaseRepository_Delete_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_Delete_Call[T]) RunAndReturn(run func(*T) error) *MockBaseRepository_Delete_Call[T] {
	_c.Call.Return(run)
	return _c
}

// DeleteMany provides a mock function with given fields: items
func (_m *MockBaseRepository[T]) DeleteMany(items *[]T) error {
	ret := _m.Called(items)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMany")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*[]T) error); ok {
		r0 = rf(items)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_DeleteMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMany'
type MockBaseRepository_DeleteMany_Call[T interface{}] struct {
	*mock.Call
}

// DeleteMany is a helper method to define mock.On call
//   - items *[]T
func (_e *MockBaseRepository_Expecter[T]) DeleteMany(items interface{}) *MockBaseRepository_DeleteMany_Call[T] {
	return &MockBaseRepository_DeleteMany_Call[T]{Call: _e.mock.On("DeleteMany", items)}
}

func (_c *MockBaseRepository_DeleteMany_Call[T]) Run(run func(items *[]T)) *MockBaseRepository_DeleteMany_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*[]T))
	})
	return _c
}

func (_c *MockBaseRepository_DeleteMany_Call[T]) Return(_a0 error) *MockBaseRepository_DeleteMany_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_DeleteMany_Call[T]) RunAndReturn(run func(*[]T) error) *MockBaseRepository_DeleteMany_Call[T] {
	_c.Call.Return(run)
	return _c
}

// GetAll provides a mock function with given fields: items, pagination, condition, relations
func (_m *MockBaseRepository[T]) GetAll(items *[]T, pagination *repository.PaginationQuery, condition *repository.Condition, relations *[]repository.Relation) error {
	ret := _m.Called(items, pagination, condition, relations)

	if len(ret) == 0 {
		panic("no return value specified for GetAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*[]T, *repository.PaginationQuery, *repository.Condition, *[]repository.Relation) error); ok {
		r0 = rf(items, pagination, condition, relations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type MockBaseRepository_GetAll_Call[T interface{}] struct {
	*mock.Call
}

// GetAll is a helper method to define mock.On call
//   - items *[]T
//   - pagination *repository.PaginationQuery
//   - condition *repository.Condition
//   - relations *[]repository.Relation
func (_e *MockBaseRepository_Expecter[T]) GetAll(items interface{}, pagination interface{}, condition interface{}, relations interface{}) *MockBaseRepository_GetAll_Call[T] {
	return &MockBaseRepository_GetAll_Call[T]{Call: _e.mock.On("GetAll", items, pagination, condition, relations)}
}

func (_c *MockBaseRepository_GetAll_Call[T]) Run(run func(items *[]T, pagination *repository.PaginationQuery, condition *repository.Condition, relations *[]repository.Relation)) *MockBaseRepository_GetAll_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*[]T), args[1].(*repository.PaginationQuery), args[2].(*repository.Condition), args[3].(*[]repository.Relation))
	})
	return _c
}

func (_c *MockBaseRepository_GetAll_Call[T]) Return(_a0 error) *MockBaseRepository_GetAll_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_GetAll_Call[T]) RunAndReturn(run func(*[]T, *repository.PaginationQuery, *repository.Condition, *[]repository.Relation) error) *MockBaseRepository_GetAll_Call[T] {
	_c.Call.Return(run)
	return _c
}

// GetBy provides a mock function with given fields: item, condition, relations
func (_m *MockBaseRepository[T]) GetBy(item *T, condition *repository.Condition, relations *[]repository.Relation) error {
	ret := _m.Called(item, condition, relations)

	if len(ret) == 0 {
		panic("no return value specified for GetBy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*T, *repository.Condition, *[]repository.Relation) error); ok {
		r0 = rf(item, condition, relations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_GetBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBy'
type MockBaseRepository_GetBy_Call[T interface{}] struct {
	*mock.Call
}

// GetBy is a helper method to define mock.On call
//   - item *T
//   - condition *repository.Condition
//   - relations *[]repository.Relation
func (_e *MockBaseRepository_Expecter[T]) GetBy(item interface{}, condition interface{}, relations interface{}) *MockBaseRepository_GetBy_Call[T] {
	return &MockBaseRepository_GetBy_Call[T]{Call: _e.mock.On("GetBy", item, condition, relations)}
}

func (_c *MockBaseRepository_GetBy_Call[T]) Run(run func(item *T, condition *repository.Condition, relations *[]repository.Relation)) *MockBaseRepository_GetBy_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T), args[1].(*repository.Condition), args[2].(*[]repository.Relation))
	})
	return _c
}

func (_c *MockBaseRepository_GetBy_Call[T]) Return(_a0 error) *MockBaseRepository_GetBy_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_GetBy_Call[T]) RunAndReturn(run func(*T, *repository.Condition, *[]repository.Relation) error) *MockBaseRepository_GetBy_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: item
func (_m *MockBaseRepository[T]) Save(item *T) error {
	ret := _m.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*T) error); ok {
		r0 = rf(item)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockBaseRepository_Save_Call[T interface{}] struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - item *T
func (_e *MockBaseRepository_Expecter[T]) Save(item interface{}) *MockBaseRepository_Save_Call[T] {
	return &MockBaseRepository_Save_Call[T]{Call: _e.mock.On("Save", item)}
}

func (_c *MockBaseRepository_Save_Call[T]) Run(run func(item *T)) *MockBaseRepository_Save_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T))
	})
	return _c
}

func (_c *MockBaseRepository_Save_Call[T]) Return(_a0 error) *MockBaseRepository_Save_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_Save_Call[T]) RunAndReturn(run func(*T) error) *MockBaseRepository_Save_Call[T] {
	_c.Call.Return(run)
	return _c
}

// SaveMany provides a mock function with given fields: items
func (_m *MockBaseRepository[T]) SaveMany(items *[]T) error {
	ret := _m.Called(items)

	if len(ret) == 0 {
		panic("no return value specified for SaveMany")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*[]T) error); ok {
		r0 = rf(items)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_SaveMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveMany'
type MockBaseRepository_SaveMany_Call[T interface{}] struct {
	*mock.Call
}

// SaveMany is a helper method to define mock.On call
//   - items *[]T
func (_e *MockBaseRepository_Expecter[T]) SaveMany(items interface{}) *MockBaseRepository_SaveMany_Call[T] {
	return &MockBaseRepository_SaveMany_Call[T]{Call: _e.mock.On("SaveMany", items)}
}

func (_c *MockBaseRepository_SaveMany_Call[T]) Run(run func(items *[]T)) *MockBaseRepository_SaveMany_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*[]T))
	})
	return _c
}

func (_c *MockBaseRepository_SaveMany_Call[T]) Return(_a0 error) *MockBaseRepository_SaveMany_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_SaveMany_Call[T]) RunAndReturn(run func(*[]T) error) *MockBaseRepository_SaveMany_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: item
func (_m *MockBaseRepository[T]) Update(item *T) error {
	ret := _m.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*T) error); ok {
		r0 = rf(item)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockBaseRepository_Update_Call[T interface{}] struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - item *T
func (_e *MockBaseRepository_Expecter[T]) Update(item interface{}) *MockBaseRepository_Update_Call[T] {
	return &MockBaseRepository_Update_Call[T]{Call: _e.mock.On("Update", item)}
}

func (_c *MockBaseRepository_Update_Call[T]) Run(run func(item *T)) *MockBaseRepository_Update_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T))
	})
	return _c
}

func (_c *MockBaseRepository_Update_Call[T]) Return(_a0 error) *MockBaseRepository_Update_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_Update_Call[T]) RunAndReturn(run func(*T) error) *MockBaseRepository_Update_Call[T] {
	_c.Call.Return(run)
	return _c
}

// UpdateMany provides a mock function with given fields: items
func (_m *MockBaseRepository[T]) UpdateMany(items *[]T) error {
	ret := _m.Called(items)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMany")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*[]T) error); ok {
		r0 = rf(items)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBaseRepository_UpdateMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMany'
type MockBaseRepository_UpdateMany_Call[T interface{}] struct {
	*mock.Call
}

// UpdateMany is a helper method to define mock.On call
//   - items *[]T
func (_e *MockBaseRepository_Expecter[T]) UpdateMany(items interface{}) *MockBaseRepository_UpdateMany_Call[T] {
	return &MockBaseRepository_UpdateMany_Call[T]{Call: _e.mock.On("UpdateMany", items)}
}

func (_c *MockBaseRepository_UpdateMany_Call[T]) Run(run func(items *[]T)) *MockBaseRepository_UpdateMany_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*[]T))
	})
	return _c
}

func (_c *MockBaseRepository_UpdateMany_Call[T]) Return(_a0 error) *MockBaseRepository_UpdateMany_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_UpdateMany_Call[T]) RunAndReturn(run func(*[]T) error) *MockBaseRepository_UpdateMany_Call[T] {
	_c.Call.Return(run)
	return _c
}

// WithTx provides a mock function with given fields: tx
func (_m *MockBaseRepository[T]) WithTx(tx *gorm.DB) repository.BaseRepository[T] {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for WithTx")
	}

	var r0 repository.BaseRepository[T]
	if rf, ok := ret.Get(0).(func(*gorm.DB) repository.BaseRepository[T]); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.BaseRepository[T])
		}
	}

	return r0
}

// MockBaseRepository_WithTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTx'
type MockBaseRepository_WithTx_Call[T interface{}] struct {
	*mock.Call
}

// WithTx is a helper method to define mock.On call
//   - tx *gorm.DB
func (_e *MockBaseRepository_Expecter[T]) WithTx(tx interface{}) *MockBaseRepository_WithTx_Call[T] {
	return &MockBaseRepository_WithTx_Call[T]{Call: _e.mock.On("WithTx", tx)}
}

func (_c *MockBaseRepository_WithTx_Call[T]) Run(run func(tx *gorm.DB)) *MockBaseRepository_WithTx_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gorm.DB))
	})
	return _c
}

func (_c *MockBaseRepository_WithTx_Call[T]) Return(_a0 repository.BaseRepository[T]) *MockBaseRepository_WithTx_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBaseRepository_WithTx_Call[T]) RunAndReturn(run func(*gorm.DB) repository.BaseRepository[T]) *MockBaseRepository_WithTx_Call[T] {
	_c.Call.Return(run)
	return _c
}

// NewMockBaseRepository creates a new instance of MockBaseRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBaseRepository[T interface{}](t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBaseRepository[T] {
	mock := &MockBaseRepository[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
